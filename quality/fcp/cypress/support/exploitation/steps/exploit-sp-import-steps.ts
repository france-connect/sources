import { DataTable, Then, When } from '@badeball/cypress-cucumber-preprocessor';

import ExploitSpImportPage from '../pages/exploit-sp-import-page';

const exploitSpImportPage = new ExploitSpImportPage();

Then(
  "je suis redirigé vers la page d'import de fournisseurs de service",
  () => {
    exploitSpImportPage.checkIsVisible();
  },
);

When(
  "je sélectionne le fichier d'import de FS {string}",
  function (fileName: string) {
    const platform = Cypress.env('PLATFORM');
    const testEnv = Cypress.env('TEST_ENV');
    const DEFAULT_FIXTURE_PATH = './cypress/fixtures';
    const pathArray = [platform, testEnv];

    cy.task('getFixturePath', { fixture: fileName, pathArray }).then(
      (fixturePath: string) => {
        exploitSpImportPage.selectFile(
          `${DEFAULT_FIXTURE_PATH}/${fixturePath}`,
        );
      },
    );
  },
);

Then(
  "le nombre de lignes du fichier d'import de FS est {int}",
  function (count: number) {
    exploitSpImportPage.checkFileLineCount(count);
  },
);

Then(
  "le message d'erreur de sélection du fichier FS est affiché",
  function (dataTable?: DataTable) {
    const [firstRow = {}] = dataTable?.hashes() || [];
    const { message = '' } = firstRow;
    exploitSpImportPage.checkIsFileSelectionErrorDisplayed(message);
  },
);

When("je valide le formulaire d'import de FS", function () {
  exploitSpImportPage.validateSpImport(this.operatorUser);
});

Then('je clique sur le bouton "importer les FS en base"', function () {
  exploitSpImportPage.getSpImportButton().click();
});

Then("le message de confirmation d'import de FS est affiché", function () {
  exploitSpImportPage.checkIsConfirmationDisplayed();
});

Then(
  "le message d'erreur d'import de FS est affiché",
  function (dataTable?: DataTable) {
    const [firstRow = {}] = dataTable?.hashes() || [];
    const { message = '' } = firstRow;
    exploitSpImportPage.checkIsImportErrorDisplayed(message);
  },
);

Then(
  "le nombre de lignes du rapport d'import de FS est {int}",
  function (count: number) {
    exploitSpImportPage.checkReportLineCount(count);
  },
);

Then(
  "le nombre de FS créés lors de l'import est {int}",
  function (count: number) {
    exploitSpImportPage.checkCreatedSpCount(count);
  },
);

Then(
  "le nombre de FS en erreur lors de l'import est {int}",
  function (count: number) {
    exploitSpImportPage.checkErroredSpCount(count);
  },
);

When(
  "je télécharge le rapport d'import de FS {string}",
  function (fileName: string) {
    exploitSpImportPage.downloadSpImportReport(fileName);
    cy.readFile(`cypress/downloads/${fileName}`).then((content) => {
      cy.task('parseCsvContent', content).then(
        (records: Record<string, unknown>[]) => {
          this.csvFiles[fileName] = records;
        },
      );
    });
  },
);

Then(
  'le fichier csv {string} contient les colonnes du fichier csv importé {string}',
  function (dowloadedFileName: string, fixtureFileName: string) {
    const records = this.csvFiles[dowloadedFileName];
    expect(records).to.exist;
    expect(records.length).to.be.greaterThan(0);
    const headers = Object.keys(records[0]);

    const platform = Cypress.env('PLATFORM');
    const filePath = `cypress/fixtures/${platform}/${fixtureFileName}`;
    cy.readFile(filePath).then((content) => {
      cy.task('parseCsvContent', content).then(
        (records: Record<string, unknown>[]) => {
          const expectedColumns = Object.keys(records[0]);

          expectedColumns.forEach((columnName) =>
            expect(headers).to.include(columnName),
          );
        },
      );
    });
  },
);

Then(
  'le fichier csv {string} contient le contenu du fichier csv importé {string}',
  function (dowloadedFileName: string, fixtureFileName: string) {
    const records = this.csvFiles[dowloadedFileName];
    expect(records).to.exist;
    expect(records.length).to.be.greaterThan(1);

    const platform = Cypress.env('PLATFORM');
    const filePath = `cypress/fixtures/${platform}/${fixtureFileName}`;
    cy.readFile(filePath).then((content) => {
      cy.task('parseCsvContent', content).then(
        (expectedRecords: Record<string, unknown>[]) => {
          expectedRecords.forEach((expectedRecord, index) => {
            const actualRecord = records[index];
            Object.entries(expectedRecord).forEach(([key, value]) => {
              expect(actualRecord).to.haveOwnProperty(key);
              expect(actualRecord[key]).to.equal(value);
            });
          });
        },
      );
    });
  },
);
