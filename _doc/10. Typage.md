# Typage

## Introduction

Typescript est utilisÃ© afin d'ajouter du typage au projet, lui donnant ainsi de la rÃ©sillience aux rÃ©gressions. Le langage participe Ã©galement Ã  l'auto-documentation du code, facilitant ainsi sa prise en main et sa maintenance. Il est fortement recommandÃ© de regarder la documentation. Voici une sÃ©lections de quelques points Ã  regarder en prioritÃ©:

- [Get started](https://www.typescriptlang.org/docs/)
- [Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
- [Creating Types from Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)

### Type `any`

**Le type `any` n'est donc pas autorisÃ© sur le projet.** Tout Ã©lÃ©ment dont le type n'est pas connu et ne pouvant faire l'objet d'une interface ou d'un type doit Ãªtre typÃ© `unknown`. Cela doit cependant rester exceptionnel et l'on prÃ©fÃ¨rera l'utilisation de gÃ©nÃ©riques et/ou compositions lorsque cela est possible.

```typescript
/**
 * ğŸ˜ Cool ğŸ˜
 */

const response: json | string = await unconsistentApiCall();

interface Metadata {
  [key: string]: unknown;
}

function handleInput(input: unknown): void {
  switch (typeof input) {
    case "number":
      handleNumber(input);
      break;
    case "string":
      handleString(input);
      break;
    case Error:
      handleError(input);
      break;
    default:
      break;
  }
}
```

```typescript
/**
 * ğŸ˜± Pas cool ğŸ˜±
 */

// Si "unconsistentApiCall" renvoi du JSON ou une chaine de charactÃ¨re, autant typer proprement.
const response: unknown = await unconsistentApiCall();

// Pourquoi faire du typescript ?
interface Metadata {
  [key: any]: any;
}

// "Any" ne forcera pas Ã  typer avant de passer Ã  une fonction acceptant un type prÃ©cis, "unknown" si.
function handleInput(input: any): void {
  switch (typeof input) {
    case "number":
      handleNumber(input);
      break;
    case "string":
      handleString(input);
      break;
    case Error:
      handleError(input);
      break;
    default:
      break;
  }
}
```

### Type `void`

L'utilisation du type `void` est obligatoire pour les fonctions n'ayant pas de retour. Ce type indique que le retour de la fonction n'est pas Ã  prendre en compte par le dÃ©veloppeur.

- ğŸš© `void` est Ã  interprÃ©ter diffÃ©rement de `undefined`.

```typescript
/**
 * ğŸ˜ Cool ğŸ˜
 */

function logSomething(): void {
  console.log("Hello world !");
}

function getUser(name: string): User | undefined {
  const user = await getUserByName(name);

  if (!user) {
    return;
  }

  console.log(`Found user "${name}" !`);
  return user;
}

function handleBar(bar: string | number | undefined): void {
  if (!bar) {
    return;
  }

  switch (typeof input) {
    case "number":
      handleNumber(input);
      break;
    case "string":
      handleString(input);
      break;
  }
}
```

```typescript
/**
 * ğŸ˜± Pas cool ğŸ˜±
 */

function logSomething(): undefined {
  console.log("Hello world !");
}

function getUser(name: string): User | void {
  const user = await getUserByName(name);

  if (!user) {
    return;
  }

  console.log(`Found user "${name}" !`);
  return user;
}
```

### SynthÃ©tiser

Typescript est un outil puissant et souple. Il est donc possible de typer Ã  peu prÃ¨s tout et de plein de faÃ§ons diffÃ©rentes.

- ğŸš© Tout les typages ne se valent pas.
- ğŸš© DÃ©river des sous types permet d'Ã©viter Ã  des interfaces de diverger, facilitant la maintenance du code.

```typescript
/**
 * ğŸ˜ Cool ğŸ˜
 */

type Gender = "M" | "F";

interface Identity {
  gender?: Gender;
  lastName: string;
  firstName: string;
  birthdate: Date;
  size: number;
}

type AnonymousIdentity = Pick<Identity, "gender", "birthdate", "size">;

function setIdentityField<IdKey extends keyof Identity>(
  identity: Identity,
  key: IdKey,
  value: Identity[IdKey]
): void {
  identity[key] = value;
}
```

```typescript
/**
 * ğŸ˜± Pas cool ğŸ˜±
 */

interface Identity {
  gender?: "M" | "F";
  lastName: string;
  firstName: string;
  birthdate: Date;
  size: number;
}

interface AnonymousIdentity {
  gender?: "M" | "F";
  birthdate: Date;
  size: number;
}

function setIdentityField(
  identity: Identity,
  key: "gender" | "lastName" | "firstName" | "birthdate" | "size",
  value: unknown
): void {
  identity[key] = value;
}
```
